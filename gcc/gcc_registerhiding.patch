diff --git a/gcc/calls.cc b/gcc/calls.cc
index 9edb5831611..cebf5f61684 100644
--- a/gcc/calls.cc
+++ b/gcc/calls.cc
@@ -506,6 +506,9 @@ emit_call_1 (rtx funexp, tree fntree ATTRIBUTE_UNUSED, tree fndecl ATTRIBUTE_UNU
   if (ecf_flags & ECF_NORETURN)
     add_reg_note (call_insn, REG_NORETURN, const0_rtx);
 
+  if (valreg && fntree && arg_int_size_in_bytes(TREE_TYPE(fntree)) > 8)
+    add_reg_note (call_insn, REG_CALL_RETLARGE, const0_rtx);
+
   if (ecf_flags & ECF_RETURNS_TWICE)
     {
       add_reg_note (call_insn, REG_SETJMP, const0_rtx);
diff --git a/gcc/combine.cc b/gcc/combine.cc
index 6344cd3c9f2..9238e79573f 100644
--- a/gcc/combine.cc
+++ b/gcc/combine.cc
@@ -14397,6 +14397,7 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,
 	case REG_CALL_DECL:
 	case REG_UNTYPED_CALL:
 	case REG_CALL_NOCF_CHECK:
+	case REG_CALL_RETLARGE:
 	  /* These notes must remain with the call.  It should not be
 	     possible for both I2 and I3 to be a call.  */
 	  if (CALL_P (i3))
diff --git a/gcc/config/i386/i386-options.cc b/gcc/config/i386/i386-options.cc
index dd5df559c84..45b77641e48 100644
--- a/gcc/config/i386/i386-options.cc
+++ b/gcc/config/i386/i386-options.cc
@@ -2746,6 +2746,10 @@ ix86_option_override_internal (bool main_args_p,
 	  = (1 << opts->x_ix86_preferred_stack_boundary_arg) * BITS_PER_UNIT;
     }
 
+  ix86_postamble_pad = 0;
+  if (opts_set->x_ix86_postamble_pad_arg)
+	ix86_postamble_pad = opts->x_ix86_postamble_pad_arg;
+
   /* Set the default value for -mstackrealign.  */
   SET_OPTION_IF_UNSET (opts, opts_set, ix86_force_align_arg_pointer,
 		       STACK_REALIGN_DEFAULT);
@@ -3381,6 +3385,8 @@ ix86_set_indirect_branch_type (tree fndecl)
 	    cfun->machine->indirect_branch_type = indirect_branch_thunk_inline;
 	  else if (strcmp (TREE_STRING_POINTER (cst), "thunk-extern") == 0)
 	    cfun->machine->indirect_branch_type = indirect_branch_thunk_extern;
+	  else if (strcmp (TREE_STRING_POINTER (cst), "thunk-extern-pad") == 0)
+	    cfun->machine->indirect_branch_type = indirect_branch_thunk_extern_pad;
 	  else
 	    gcc_unreachable ();
 	}
diff --git a/gcc/config/i386/i386-opts.h b/gcc/config/i386/i386-opts.h
index 4d293edb399..661be45d7e4 100644
--- a/gcc/config/i386/i386-opts.h
+++ b/gcc/config/i386/i386-opts.h
@@ -112,7 +112,8 @@ enum indirect_branch {
   indirect_branch_keep,
   indirect_branch_thunk,
   indirect_branch_thunk_inline,
-  indirect_branch_thunk_extern
+  indirect_branch_thunk_extern,
+  indirect_branch_thunk_extern_pad
 };
 
 enum instrument_return {
diff --git a/gcc/config/i386/i386.cc b/gcc/config/i386/i386.cc
index bd340582a33..932eb64500c 100644
--- a/gcc/config/i386/i386.cc
+++ b/gcc/config/i386/i386.cc
@@ -376,6 +376,9 @@ unsigned int ix86_incoming_stack_boundary;
 /* True if there is no direct access to extern symbols.  */
 bool ix86_has_no_direct_extern_access;
 
+/* Post-postamble padding */
+unsigned int ix86_postamble_pad;
+
 /* Calling abi specific va_list type nodes.  */
 tree sysv_va_list_type_node;
 tree ms_va_list_type_node;
@@ -5997,8 +6000,10 @@ enum indirect_thunk_prefix
 indirect_thunk_need_prefix (rtx_insn *insn)
 {
   enum indirect_thunk_prefix need_prefix;
-  if ((cfun->machine->indirect_branch_type
-	    == indirect_branch_thunk_extern)
+  if (((cfun->machine->indirect_branch_type
+	    == indirect_branch_thunk_extern) ||
+       (cfun->machine->indirect_branch_type
+	    == indirect_branch_thunk_extern_pad))
 	   && ix86_notrack_prefixed_insn_p (insn))
     {
       /* NOTRACK prefix is only used with external thunk so that it
@@ -6015,7 +6020,7 @@ indirect_thunk_need_prefix (rtx_insn *insn)
 static void
 indirect_thunk_name (char name[32], unsigned int regno,
 		     enum indirect_thunk_prefix need_prefix,
-		     bool ret_p)
+		     bool ret_p, bool is_jmp)
 {
   if (regno != INVALID_REGNUM && regno != CX_REG && ret_p)
     gcc_unreachable ();
@@ -6035,7 +6040,17 @@ indirect_thunk_name (char name[32], unsigned int regno,
       else
 	prefix = "";
 
-      const char *ret = ret_p ? "return" : "indirect";
+      const char *ret;
+      const char *full="";
+      if (cfun->machine->indirect_branch_type == indirect_branch_thunk_extern_pad)
+	      ret = ret_p ? "return" : is_jmp ? "indirect_jump" : "indirect_call";
+      else
+	      ret = ret_p ? "return" : "indirect";
+
+      if (flag_function_postamble) {
+	      if (ret_p && arg_int_size_in_bytes(TREE_TYPE(TREE_TYPE(cfun->decl)))>8)
+		      full = "_full";
+      }
 
       if (regno != INVALID_REGNUM)
 	{
@@ -6048,7 +6063,7 @@ indirect_thunk_name (char name[32], unsigned int regno,
 		   ret, prefix, reg_prefix, reg_names[regno]);
 	}
       else
-	sprintf (name, "__x86_%s_thunk%s", ret, prefix);
+	sprintf (name, "__x86_%s_thunk%s%s", ret, prefix, full);
     }
   else
     {
@@ -6170,7 +6185,7 @@ output_indirect_thunk_function (enum indirect_thunk_prefix need_prefix,
   tree decl;
 
   /* Create __x86_indirect_thunk.  */
-  indirect_thunk_name (name, regno, need_prefix, ret_p);
+  indirect_thunk_name (name, regno, need_prefix, ret_p, false);
   decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
 		     get_identifier (name),
 		     build_function_type_list (void_type_node, NULL_TREE));
@@ -7368,13 +7383,26 @@ ix86_emit_save_regs (void)
 
   if (!TARGET_APX_PUSH2POP2 || cfun->machine->func_type != TYPE_NORMAL)
     {
-      for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)
-	if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true, true))
+      if (flag_invert_save_order)
+       {
+	for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+	 if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true, true))
 	  {
 	    insn = emit_insn (gen_push (gen_rtx_REG (word_mode, regno),
 					TARGET_APX_PPX));
 	    RTX_FRAME_RELATED_P (insn) = 1;
 	  }
+       }
+      else
+       {
+	for (regno = FIRST_PSEUDO_REGISTER - 1; regno >= 0; regno--)
+	 if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, true, true))
+	  {
+	    insn = emit_insn (gen_push (gen_rtx_REG (word_mode, regno),
+					TARGET_APX_PPX));
+	    RTX_FRAME_RELATED_P (insn) = 1;
+	  }
+       }
     }
   else
     {
@@ -9412,9 +9440,18 @@ ix86_emit_restore_regs_using_pop (bool ppx_p)
 {
   unsigned int regno;
 
-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
-    if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, false, true))
-      ix86_emit_restore_reg_using_pop (gen_rtx_REG (word_mode, regno), ppx_p);
+  if (flag_invert_save_order)
+   {
+	for (regno = FIRST_PSEUDO_REGISTER-1; regno-- > 0;)
+	 if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, false, true))
+	  ix86_emit_restore_reg_using_pop (gen_rtx_REG (word_mode, regno), ppx_p);
+   }
+  else
+   {
+	for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)
+	 if (GENERAL_REGNO_P (regno) && ix86_save_reg (regno, false, true))
+	  ix86_emit_restore_reg_using_pop (gen_rtx_REG (word_mode, regno), ppx_p);
+   }
 }
 
 /* Emit code to restore saved registers using POP2 insns.  */
@@ -10240,9 +10277,29 @@ ix86_print_patchable_function_entry (FILE *file,
 	 place.  There is nothing to do here.  */
       return;
     }
+  if (flag_indirect_preamble)
+  {
+	  const char *f_name = "__x86_indirect_preamble";
+	  bool need_endbr = (flag_cf_protection & CF_BRANCH);
+	  long unsigned int req_size = need_endbr ? 13 : 9;
+	  if (patch_area_size < req_size) {
+		  error ("insufficient patch area");
+		  return;
+	  }
+	  default_print_patchable_function_entry (file, patch_area_size-req_size,
+						  record_p);
 
-  default_print_patchable_function_entry (file, patch_area_size,
-					  record_p);
+	  fprintf(asm_out_file, "\t.byte 0xeb, 0xfe\n");
+
+	  if (need_endbr)
+		  fprintf(asm_out_file, "\tendbr64\n");
+	  fprintf(asm_out_file, "\txorps %%xmm11,%%xmm11\n");
+	  fprintf(asm_out_file, "\tcall\t");
+	  assemble_name(asm_out_file, f_name);
+	  putc('\n', asm_out_file);
+  } else
+	  default_print_patchable_function_entry (file, patch_area_size,
+						  record_p);
 }
 
 /* Output patchable area.  NB: default_print_patchable_function_entry
@@ -16781,7 +16838,7 @@ ix86_output_indirect_branch_via_reg (rtx call_op, bool sibcall_p)
       if (cfun->machine->indirect_branch_type == indirect_branch_thunk)
 	SET_HARD_REG_BIT (indirect_thunks_used, regno);
 
-      indirect_thunk_name (thunk_name_buf, regno, need_prefix, false);
+      indirect_thunk_name (thunk_name_buf, regno, need_prefix, false, sibcall_p);
       thunk_name = thunk_name_buf;
     }
   else
@@ -16799,6 +16856,9 @@ ix86_output_indirect_branch_via_reg (rtx call_op, bool sibcall_p)
 	  fprintf (asm_out_file, "\tcall\t");
 	  assemble_name (asm_out_file, thunk_name);
 	  putc ('\n', asm_out_file);
+	  if (cfun->machine->indirect_branch_type == indirect_branch_thunk_extern_pad)
+		  //fprintf(asm_out_file, "\tcs\tnop\n");
+		  fprintf(asm_out_file, "\t.byte 0x0f, 0x1f, 0x00\n");
 	  return;
 	}
 
@@ -16864,7 +16924,7 @@ ix86_output_indirect_branch_via_push (rtx call_op, const char *xasm,
     {
       if (cfun->machine->indirect_branch_type == indirect_branch_thunk)
 	indirect_thunk_needed = true;
-      indirect_thunk_name (thunk_name_buf, regno, need_prefix, false);
+      indirect_thunk_name (thunk_name_buf, regno, need_prefix, false, sibcall_p);
       thunk_name = thunk_name_buf;
     }
   else
@@ -17029,7 +17089,7 @@ ix86_output_function_return (bool long_p)
 	  bool need_thunk = (cfun->machine->function_return_type
 			     == indirect_branch_thunk);
 	  indirect_thunk_name (thunk_name, INVALID_REGNUM, need_prefix,
-			       true);
+			       true, false);
 	  indirect_return_needed |= need_thunk;
 	  fprintf (asm_out_file, "\tjmp\t");
 	  assemble_name (asm_out_file, thunk_name);
@@ -17064,7 +17124,7 @@ ix86_output_indirect_function_return (rtx ret_op)
 	{
 	  bool need_thunk = (cfun->machine->function_return_type
 			     == indirect_branch_thunk);
-	  indirect_thunk_name (thunk_name, regno, need_prefix, true);
+	  indirect_thunk_name (thunk_name, regno, need_prefix, true, false);
 
 	  if (need_thunk)
 	    {
@@ -17220,11 +17280,30 @@ ix86_output_call_insn (rtx_insn *insn, rtx call_op)
 	xasm = "%!call\t%A0";
     }
 
+  //NOPs to break non-arch XMM reads/writes
+  fprintf(asm_out_file, "\t.byte 0x0f, 0x1f, 0x00\n");
+
   if (output_indirect_p && !direct_p)
     ix86_output_indirect_branch (call_op, xasm, false);
   else
     output_asm_insn (xasm, &call_op);
 
+  if (flag_function_postamble){
+	  const char *f_name = "__x86_function_postamble";
+	  const char *f_namefull = "__x86_function_postamble_full";
+	  fprintf(asm_out_file, "\txorps %%xmm11,%%xmm11\n");
+	  fprintf(asm_out_file, "\tcall\t");
+	  if (find_reg_note(insn, REG_CALL_RETLARGE, 0)) {
+	     assemble_name(asm_out_file, f_namefull);
+	     putc('\n', asm_out_file);
+	  } else {
+	     assemble_name(asm_out_file, f_name);
+	     putc('\n', asm_out_file);
+	     for (unsigned int i=0; i<ix86_postamble_pad; i++)
+		fprintf(asm_out_file, "\tnop\n");
+	  }
+  }
+
   if (seh_nop_p)
     return "nop";
 
@@ -22649,11 +22728,19 @@ x86_field_alignment (tree type, int computed)
 static void
 x86_print_call_or_nop (FILE *file, const char *target)
 {
-  if (flag_nop_mcount || !strcmp (target, "nop"))
+  if (flag_nop_mcount || !strcmp (target, "nop")){
     /* 5 byte nop: nopl 0(%[re]ax,%[re]ax,1) */
     fprintf (file, "1:" ASM_BYTE "0x0f, 0x1f, 0x44, 0x00, 0x00\n");
-  else
+  }else if (flag_function_postamble){
+    /* Add 6 extra bytes (4 for clear XMM and 2 for indirect call) */
+      fprintf (file, "1:\tcall\t%s\n", target);
+      //NOP4
+      fprintf (file, "\t.byte 0x0f, 0x1f, 0x40, 0x00\n");
+      //NOP2
+      fprintf (file, "\tdata16 nop\n");
+  }else{
     fprintf (file, "1:\tcall\t%s\n", target);
+  }
 }
 
 static bool
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
index 9c74b3ebd90..845b9314ddb 100644
--- a/gcc/config/i386/i386.h
+++ b/gcc/config/i386/i386.h
@@ -2486,6 +2486,8 @@ extern enum processor_type ix86_arch;
 extern unsigned int ix86_preferred_stack_boundary;
 extern unsigned int ix86_incoming_stack_boundary;
 
+extern unsigned int ix86_postamble_pad;
+
 /* Smallest class containing REGNO.  */
 extern enum reg_class const regclass_map[FIRST_PSEUDO_REGISTER];
 
diff --git a/gcc/config/i386/i386.opt b/gcc/config/i386/i386.opt
index b2edfac0b2a..47e3cf64ec0 100644
--- a/gcc/config/i386/i386.opt
+++ b/gcc/config/i386/i386.opt
@@ -207,6 +207,10 @@ int x_ix86_tune_no_default
 TargetVariable
 enum ix86_veclibabi ix86_veclibabi_type = ix86_veclibabi_type_none
 
+;; -mpostamble-pad=
+TargetVariable
+int ix86_postamble_pad_arg
+
 ;; x86 options
 m128bit-long-double
 Target RejectNegative Mask(128BIT_LONG_DOUBLE) Save
@@ -1111,6 +1115,26 @@ Enum(indirect_branch) String(thunk-inline) Value(indirect_branch_thunk_inline)
 EnumValue
 Enum(indirect_branch) String(thunk-extern) Value(indirect_branch_thunk_extern)
 
+EnumValue
+Enum(indirect_branch) String(thunk-extern-pad) Value(indirect_branch_thunk_extern_pad)
+
+mfunction-postamble
+Target Var(flag_function_postamble) Init(0)
+Add call to __x86_function_postamble after all calls
+
+mpostamble-pad=
+Target RejectNegative Joined UInteger Var(ix86_postamble_pad_arg)
+Add this many bytes of padding after postamble calls
+
+mindirect-preamble
+Target Var(flag_indirect_preamble) Init(0)
+Add call to __x86_indirect_preamble at the end of the pfx section of each function
+
+minvert-save-order
+Target Var(flag_invert_save_order) Init(0)
+Invert the order that callee-saved registers are saved on the stack in the
+function prologue
+
 mindirect-branch-cs-prefix
 Target Var(ix86_indirect_branch_cs_prefix) Init(0)
 Add CS prefix to call and jmp to indirect thunk with branch target in r8-r15 registers.
diff --git a/gcc/reg-notes.def b/gcc/reg-notes.def
index 5cbe35dfe36..58592e884b7 100644
--- a/gcc/reg-notes.def
+++ b/gcc/reg-notes.def
@@ -253,3 +253,6 @@ REG_NOTE (CALL_NOCF_CHECK)
 
 /* The values passed to callee, for debuginfo purposes.  */
 REG_NOTE (CALL_ARG_LOCATION)
+
+/* Indicates that the call returns a >8B value */
+REG_NOTE (CALL_RETLARGE)
